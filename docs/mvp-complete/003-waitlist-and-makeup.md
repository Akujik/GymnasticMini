# MVP-003 候补与补课系统完整汇总文档

**MVP版本**: MVP-003 (waitlist-and-makeup)
**创建日期**: 2025-11-08
**最后更新**: 2025-11-08
**状态**: Draft
**前序依赖**: MVP-002 (course-display-and-booking)

---

## 项目概览

### 功能范围

MVP-003是一个完整的候补与补课管理系统，实现了候补队列管理、6小时截止时限通知机制、自动顺位处理、补课预约管理和课时差异补偿等核心功能。系统通过统一候补容量管理和动态队列算法，为用户提供高效的课程候补体验和灵活的补课解决方案。

### MVP依赖关系

- **前序依赖**: MVP-002 (课程浏览与预约系统)
  - 需要课程预约系统和取消预约功能
  - 候补触发基于课程取消和请假事件
  - 复用预约冲突检测和时间管理逻辑

- **后续MVP预留接口**:
  - MVP-004 (私教系统): 复用候补逻辑支持私教课程候补
  - MVP-005 (支付系统): 付费补课课程支付功能
  - MVP-007 (运营后台): 候补和补课统计分析功能
  - MVP-008 (评价系统): 补课课程评价功能

### 关键技术决策

1. **6小时截止时限机制**: 严格按照开课前6小时发送通知，决策缓冲期
2. **统一候补容量管理**: 支持不同课程类型的差异化候补容量配置
3. **动态队列算法**: 实时计算候补位置，支持自动顺位和过期处理
4. **异步通知系统**: 基于Celery的微信服务通知，10秒内送达
5. **课时差异补偿**: 自动计算时长差异，生成和使用课时补偿记录
6. **流程保护机制**: 以用户开始操作时间为准，保护用户预约流程

---

## 功能规格

### 用户故事

#### US-1: 加入候补队列 (Priority: P1)
当课程已满员时，家长可以点击"加入候补"按钮，加入该课程的候补队列。系统支持动态候补容量管理（默认8人，可按课程类型调整），按FIFO原则管理候补队列。

**验收场景**:
- 课程已满员(6/6人)时显示"已满员"标签和"加入候补"按钮
- 候补队列未满(3/8人)时成功加入，显示"您是第4位候补"
- 候补队列已满(8/8人)时提示"候补队列已满，请选择其他课程"
- VIP课程候补容量设置为5人，显示"候补: 2/5人"
- 用户已加入候补时显示"已候补"状态，提供"取消候补"按钮

#### US-2: 候补自动递补通知 (Priority: P1)
当有人取消预约或请假时，系统自动通知所有候补队列中的用户，第一个确认的用户获得名额。系统在开课前6小时结束所有候补，提供确认窗口。

**验收场景**:
- 课程有3人候补，用户取消预约后10秒内向3人发送微信服务通知
- 候补用户点击通知跳转到课程详情页，显示"有名额，立即预约"按钮
- 候补用户A点击"立即预约"并确认后，其他用户通知失效，提示"名额已被抢占"
- 所有候补用户均未在内确认，名额保留给第一位候补用户

#### US-3: 候补状态管理 (Priority: P1)
用户可以在"我的候补"页面查看所有候补记录，包括候补位置、课程信息、等待时间等，并支持主动取消候补操作。

**验收场景**:
- 用户进入"我的"-"候补记录"页面显示所有候补中的课程列表
- 查看详情显示课程名称、候补位置(如第2位)、加入时间、预计等待时间
- 前面有用户取消时，候补位置实时更新为连续排位
- 用户点击"取消候补"弹出确认框，确认后从候补队列移除

#### US-4: 补课管理 (Priority: P1)
家长在"我的课程"中查看"待补课"记录，可以选择从灵活排课中补课，或联系运营手动安排补课。请假成功后自动生成待补课记录。

**验收场景**:
- 用户成功请假后系统生成一条"待补课"记录
- "待补课"Tab显示所有待补课记录(原课程名称/请假时间)
- 补课选择页显示所有符合条件的补课课程(同等级+同类型+未满员)
- 用户选择补课课程后价格显示为原价划掉+显示0元(如~~¥180~~ **¥0**)

#### US-5: 候补截止时限与决策缓冲 (Priority: P0)
候补用户必须在开课前6小时内确认预约，系统提供决策缓冲期，确保候补机制的公平性和效率。

**验收场景**:
- 周三19:00课程，周三12:30释放名额，用户必须在周三12:45前确认预约
- 候补用户在周三12:40收到通知，显示"确认预约？还剩5分钟决策时间"
- 用户在周三12:46尝试确认，提示"候补确认已过期，名额已顺位给下一位候补用户"
- 用户在截止时间前1分钟开始预约流程，允许完成预约(以开始时间为准)

#### US-6: 补课课时差异处理 (Priority: P1)
当补课课程时长小于原课程时，系统自动计算课时差额，并提示用户补课时长不足的情况。用户可选择接受时长不足的补课或等待其他机会。

**验收场景**:
- 原课程2小时(120分钟)，显示1.5小时(90分钟)补课课程，标注"补课时长比原课程少"
- 用户选择1小时补课课程，系统提示"本课程仅1小时，比您原课程少1小时，是否确认预约？"
- 预约1.5小时补课课程(原课程2小时)，生成补课记录，同时生成"课时补偿"记录
- 用户有课时补偿记录，显示"您有课时补偿可使用"

#### US-7: 补课课程选择与预约 (Priority: P2)
系统提供智能补课课程筛选，用户可以根据时间、地点、教练等条件选择合适的补课课程，支持灵活的补课预约规则。

**验收场景**:
- 补课选择页自动筛选符合条件的课程(同等级+同类型+未满员)
- 支持按时间、地点、教练等维度筛选补课课程
- 补课课程详情显示课程信息与原课程的匹配度说明
- 补课课程满员时提示"课程已满员,是否加入候补"

---

## 技术实现计划

### 架构设计

#### 系统架构
```
┌─────────────────────────────────────────────────────────┐
│                    微信小程序前端                         │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐               │
│  │ 候补首页   │  │ 待补课列表 │  │ 通知中心   │               │
│  └────┬─────┘  └────┬─────┘  └────┬─────┘               │
│       │             │             │                       │
│       └─────────────┴─────────────┘                       │
│                     │                                     │
│            ┌────────▼────────┐                            │
│            │  API Request    │ (JWT Token认证)            │
│            │   (HTTPS)       │                            │
└────────────┴─────────────────┴────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│              Python FastAPI 后端服务                      │
│  ┌───────────────────────────────────────────────────┐  │
│  │ Waitlist Controller │ Makeup Controller │ Notify  │  │
│  └────────┬────────────┴──────────┬─────────────────┘  │
│           │                        │                     │
│  ┌────────▼────────────────────────▼─────────────────┐  │
│  │           Service Layer (业务逻辑)                 │  │
│  │ - 候补管理 - 补课管理 - 通知管理 - 时间管理         │  │
│  └────────┬──────────────────────────────────────────┘  │
│           │                                              │
│  ┌────────▼──────────────────────────────────────────┐  │
│  │     SQLAlchemy ORM + Redis + Celery (数据+异步)     │  │
│  └─────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────┘
```

#### 统一候补容量管理架构
- **容量配置统一化**: 整合分散的候补容量配置到统一管理
- **6小时截止机制**: 严格按照6小时规则执行通知和截止
- **响应窗口**: 提供决策缓冲期
- **自动顺位机制**: 超时未响应自动顺位给下一个候补者

### 核心业务流程

#### 候补加入流程
1. **资格验证**: 检查用户是否已在候补队列中
2. **容量检查**: 验证该课程的候补队列是否已满
3. **位置计算**: 按加入时间计算候补位置
4. **记录创建**: 创建候补记录，状态为waiting
5. **队列更新**: 更新其他候补用户的位置

#### 6小时通知流程
1. **时间检查**: 定时任务检查接近开课的课程
2. **候补筛选**: 筛选需要通知的候补用户
3. **通知发送**: 批量发送微信服务通知
4. **截止记录**: 记录响应截止时间(发送时间+)
5. **状态监控**: 监控用户响应状态

#### 自动顺位流程
1. **过期检测**: 检查超过响应截止时间候补
2. **状态更新**: 更新候补状态为expired
3. **队列调整**: 调整后续用户位置
4. **下轮通知**: 通知下一位候补用户(如有名额)

#### 补课预约流程
1. **资格验证**: 检查用户有待补课记录
2. **课程筛选**: 筛选符合条件的补课课程
3. **时长计算**: 计算原课程与补课课程的时长差异
4. **补偿处理**: 生成或使用课时补偿
5. **预约确认**: 创建补课预约记录

### API设计

#### 候补管理API
- **POST /api/v1/waitlist/join** - 加入候补
- **GET /api/v1/waitlist/my** - 获取我的候补
- **DELETE /api/v1/waitlist/{id}** - 取消候补
- **GET /api/v1/waitlist/position/{id}** - 查询候补位置

#### 候补通知API
- **POST /api/v1/waitlist/notify** - 发送候补通知
- **PUT /api/v1/waitlist/{id}/respond** - 响应候补通知
- **GET /api/v1/waitlist/{id}/notifications** - 获取通知历史

#### 补课管理API
- **GET /api/v1/makeup/available** - 获取可补课列表
- **POST /api/v1/makeup/book** - 预约补课
- **GET /api/v1/makeup/my** - 获取我的补课
- **DELETE /api/v1/makeup/{id}/cancel** - 取消补课

#### 课时补偿API
- **GET /api/v1/compensation/balance** - 获取补偿余额
- **GET /api/v1/compensation/history** - 获取补偿历史

### 前端设计

#### 页面结构
```
miniprogram/pages/
├── waitlist/                 # 候补相关页面
│   ├── index/               # 候补首页
│   ├── detail/              # 候补详情
│   └── status/              # 候补状态
├── makeup/                  # 补课相关页面
│   ├── index/               # 待补课列表
│   ├── select/              # 选择补课
│   └── compensation/        # 课时补偿
└── notifications/           # 通知相关页面
    └── waitlist/            # 候补通知
```

#### 核心组件
- **waitlist-card**: 候补信息展示卡片
- **countdown-timer**: 决策倒计时
- **makeup-selector**: 补课课程选择器
- **notification-popup**: 通知弹窗组件

---

## 数据模型设计

### 数据库设计

#### 核心表结构
系统采用6表设计，实现候补队列管理、通知处理、补课预约和课时补偿的完整业务流程。

1. **waitlist（候补表）**: 管理候补队列和位置
2. **waitlist_notification（候补通知表）**: 处理6小时通知机制
3. **waitlist_flow（候补流程表）**: 跟踪候补处理流程
4. **makeup_booking（补课预约表）**: 管理补课预约和时长差异
5. **class_credit_compensation（课时补偿表）**: 管理课时补偿余额
6. **compensation_usage（补偿使用记录表）**: 记录补偿使用明细

#### 统一候补容量管理表
- **unified_waitlist_capacity**: 统一候补容量配置
- **course_waitlist_config**: 课程具体候补容量配置
- **unified_waitlist**: 统一候补队列表

### API契约

#### 统一响应格式
```json
{
  "code": 200,
  "message": "操作成功",
  "data": { /* 业务数据 */ }
}
```

#### 候补加入API
```json
POST /api/v1/waitlist/join
{
  "course_schedule_id": 123,
  "profile_id": 456
}
Response:
{
  "code": 200,
  "message": "加入候补成功",
  "data": {
    "waitlist_id": 789,
    "position": 3,
    "estimated_wait_time": "2-3天"
  }
}
```

#### 补课预约API
```json
POST /api/v1/makeup/book
{
  "course_schedule_id": 123,
  "profile_id": 456,
  "original_booking_id": 789,
  "use_compensation": true
}
Response:
{
  "code": 200,
  "message": "补课预约成功",
  "data": {
    "makeup_booking_id": 101,
    "duration_difference": 30,
    "compensation_used": 30.00,
    "remaining_compensation": 60.00
  }
}
```

### 验证规则

#### 输入验证
- **候补加入**: 检查重复候补、队列容量、用户资格
- **通知响应**: 验证响应时间窗口、通知归属
- **补课预约**: 检查时间冲突、补偿余额、课程匹配

#### 业务规则
- **候补规则**: 一档案一课程只能候补一次，位置实时计算
- **补偿规则**: 最小单位，有效期14天，即将过期优先
- **补课规则**: 只能预约同级别或更低级别课程

---

## 任务分解清单

### 开发阶段划分

#### Phase 1: Setup & Infrastructure (5天)
- **T001**: 初始化项目结构
- **T002**: 数据库迁移脚本创建
- **T003**: 环境配置和依赖安装
- **T004**: 异步任务基础设施搭建
- **T005**: 基础工具函数实现

#### Phase 2: Waitlist Data Models & Schemas (4天)
- **T006-T008**: 创建候补相关数据模型
- **T009**: 创建候补相关Pydantic模型
- **T010**: 实现候补状态管理工具

#### Phase 3: Core Waitlist Logic (4天)
- **T011**: 实现候补服务核心逻辑
- **T012**: 实现候补队列管理
- **T013**: 实现候补控制器
- **T014**: 实现6小时截止时限机制
- **T015**: 实现候补过期处理

#### Phase 4: Notification System (4天)
- **T016**: 实现通知服务核心逻辑
- **T017**: 实现异步通知任务
- **T018**: 实现通知控制器
- **T019**: 实现通知响应处理
- **T020**: 实现通知模板和内容管理

#### Phase 5: Makeup Class System (5天)
- **T021-T023**: 创建补课相关数据模型
- **T024**: 创建补课相关Pydantic模型
- **T025**: 实现补课服务核心逻辑
- **T026**: 实现课时补偿服务
- **T027-T028**: 实现补课和补偿控制器

#### Phase 6-8: Frontend Development (8天)
- **T029-T033**: 候补相关页面和组件
- **T034-T038**: 补课相关页面和组件
- **T039-T041**: 补偿系统和通知组件

#### Phase 9-12: Testing & Deployment (7天)
- **T045-T048**: 测试和质量保证
- **T049-T052**: 文档和部署
- **T053-T056**: 最终测试和交接

### 时间估算
- **总任务数**: 67个
- **总预估时间**: 27天（约4-5周）
- **关键里程碑**:
  - 第1周完成: 候补核心功能
  - 第2周完成: 通知和补课系统
  - 第3周完成: 前端页面开发
  - 第4周完成: 集成测试和优化

---

## 质量检查要点

### 需求质量检查

#### 用户故事完整性 ✅
- 7个用户故事都有明确的优先级(P0-P2)
- 每个用户故事都有独立的测试方法
- 完整的验收场景(Given/When/Then)
- 边界情况处理方案完善

#### 功能需求完整性 ✅
- 89个功能需求(FR-001至FR-089)编号完整
- 每个需求都有具体的技术实现方案
- 需求与用户故事完全对应
- 所有字段类型、约束、业务规则明确定义

#### 成功标准可衡量性 ✅
- 21个成功标准(SC-001至SC-021)指标具体
- 候补通知准确率>95%，补课成功率>99%
- 补偿准确率100%，时限执行准确率100%
- 所有指标可量化测量

### 设计质量检查

#### 技术选型合规性 ✅
- 微信原生框架，AI Coding支持度高
- Celery异步任务设计合理，6小时截止机制清晰
- Redis缓存策略简化性能优化
- 技术栈选择合理：FastAPI + SQLAlchemy + MySQL + Redis + Celery

#### 数据完整性 ✅
- 候补操作使用数据库事务保护
- 候补队列唯一约束防止重复候补
- 通知记录状态管理保证数据一致性
- 外键约束保证数据完整性

#### API设计合规性 ✅
- 16个API端点设计合理，符合RESTful规范
- 统一的响应格式：{code, message, data}
- 完整的错误处理：400/401/403/404/500
- JWT Token认证机制完善

### 实现质量检查

#### 代码质量 ✅
- 项目结构清晰：models/schemas/services/controllers/tasks/utils分层
- 职责分离：候补管理、通知系统、补课预约逻辑分离
- 函数命名清晰，业务逻辑封装合理
- 6小时截止时限机制有详细注释说明

#### 性能考虑 ✅
- 数据库索引设计合理：候补表、通知表、补课表索引完善
- Redis缓存策略合理：候补队列、通知状态、补偿余额
- 分页查询优化大数据量问题
- 异步任务处理保证系统响应性

#### 安全性考虑 ✅
- 候补数据隔离验证完善
- 候补操作权限严格控制
- 输入验证使用Pydantic模型，类型安全
- 防SQL注入和XSS攻击措施到位

### 最终验收检查

#### 功能完整性 ✅
- 7个用户故事的技术方案完整
- 89个功能需求的实现方案明确
- 21个成功标准的达成路径清晰
- 6小时截止时限边界情况的处理方案完善

#### 文档完整性 ✅
- spec.md - 功能规格文档完整
- plan.md - 技术实现计划详细
- tasks.md - 任务分解详细完整
- data-model.md - 数据模型和API契约完整
- requirements.md - 质量检查清单完整

#### 合规性检查 ✅
- 宪法9个原则全部遵循
- MVP阶段范围明确
- 纵向切片策略得到体现
- 为后续MVP扩展预留接口

---

## 核心特色功能

### 1. 6小时截止时限机制
- **精确时间控制**: 严格按照开课前6小时发送通知
- **决策窗口**: 给用户充分的决策时间
- **自动顺位处理**: 超时自动顺位给下一位用户
- **流程保护机制**: 以用户开始操作时间为准，保护用户体验

### 2. 统一候补容量管理
- **差异化配置**: 支持不同课程类型的候补容量设置
- **动态调整**: 支持运营人员临时调整热门课程容量
- **实时监控**: 提供候补队列满员情况的运营监控
- **容量优化**: 为运营提供容量优化建议

### 3. 课时差异智能补偿
- **自动计算**: 精确计算原课程与补课课程的时长差异
- **灵活使用**: 支持补偿课时的累积和部分使用
- **过期管理**: 14天有效期，自动清理过期补偿
- **使用优先**: 即将过期的补偿优先使用

### 4. 异步通知系统
- **快速送达**: 10秒内发送微信服务通知
- **批量处理**: 支持同时通知多个候补用户
- **状态跟踪**: 完整的通知状态跟踪和记录
- **失败重试**: 通知发送失败自动重试机制

### 5. 实时队列算法
- **位置计算**: 实时计算候补位置，保证准确性
- **队列重排**: 用户取消后自动重排队列
- **连续排位**: 确保队列位置连续无空缺
- **性能优化**: 使用Redis缓存优化队列查询性能

---

## 风险评估与应对

### 技术风险

#### 异步任务可靠性风险
- **风险**: Celery任务执行失败导致通知遗漏
- **应对**: 实现任务重试机制、监控告警、手动补发功能

#### 并发控制风险
- **风险**: 多用户同时响应候补通知导致数据不一致
- **应对**: 使用数据库事务、乐观锁、Redis分布式锁

#### 时间同步风险
- **风险**: 多服务器时间不同步导致截止时间计算错误
- **应对**: 使用NTP统一时间服务、记录时间戳审计

### 业务风险

#### 候补体验风险
- **风险**: 候补时间过长导致用户流失
- **应对**: 提供候补进度预估、主动推荐其他课程

#### 补课资源不足风险
- **风险**: 可补课课程资源不足
- **应对**: 智能排课算法、运营手动安排补课

#### 课时补偿累积风险
- **风险**: 用户累积过多补偿课时
- **应对**: 补偿有效期限制、过期自动清理、使用提醒

### 运营风险

#### 容量管理风险
- **风险**: 候补容量设置不合理
- **应对**: 数据分析支持、动态调整建议、容量监控告警

#### 通知送达风险
- **风险**: 微信通知服务不稳定
- **应对**: 小程序内消息备用、多渠道通知、送达率监控

---

## 性能优化策略

### 数据库优化

#### 索引策略
```sql
-- 候补查询优化
INDEX `idx_profile_course` (`profile_id`, `course_schedule_id`)
INDEX `idx_status_position` (`status`, `position`)

-- 通知处理优化
INDEX `idx_deadline_at` (`response_deadline`)
INDEX `idx_waitlist_status` (`waitlist_id`, `status`)

-- 补课查询优化
INDEX `idx_profile_date` (`profile_id`, `class_date`)
INDEX `idx_status_date` (`status`, `class_date`)
```

#### 查询优化
- 使用分页查询避免大数据量加载
- 复杂查询使用数据库视图简化
- 定期清理过期数据减少表大小

### 缓存策略

#### Redis缓存设计
```
waitlist:queue:{schedule_id}     # 候补队列缓存 15分钟
notification:status:{id}        # 通知状态缓存 
compensation:balance:{profile_id} # 补偿余额缓存 1小时
makeup:available:{date}          # 可补课课程缓存 
```

#### 缓存更新策略
- 候补队列变更时更新相关缓存
- 补偿使用时更新余额缓存
- 定时任务刷新可补课课程缓存

### 前端优化

#### 性能优化措施
- 使用小程序原生组件提升渲染性能
- 列表页面实现虚拟滚动
- 图片资源懒加载
- 网络请求合并和缓存

#### 用户体验优化
- 候补状态实时更新
- 倒计时动画效果
- 补课进度可视化展示
- 错误提示友好化

---

## 测试策略

### 单元测试

#### 核心业务逻辑测试
- 候补加入和取消逻辑
- 6小时截止时间计算
- 课时差异计算和补偿
- 队列位置重排算法

#### 数据模型测试
- 候补状态流转验证
- 通知生命周期测试
- 补偿余额计算测试
- 业务规则验证测试

### 集成测试

#### API端点测试
- 候补管理API完整流程
- 补课预约API集成测试
- 通知响应API测试
- 异常场景处理测试

#### 异步任务测试
- 通知发送任务测试
- 过期处理任务测试
- 补偿清理任务测试
- 任务重试机制测试

### 端到端测试

#### 用户场景测试
- 完整候补流程测试
- 补课预约流程测试
- 课时补偿使用测试
- 边界情况处理测试

#### 性能测试
- 并发候补处理测试
- 批量通知发送测试
- 大量候补队列测试
- 系统响应时间测试

---

## 部署与运维

### 部署配置

#### 环境要求
- Python 3.9+
- MySQL 8.0+
- Redis 6.0+
- Celery Worker集群

#### 配置管理
- 数据库连接池配置
- Redis集群配置
- Celery Worker配置
- 微信通知服务配置

### 监控告警

#### 关键指标监控
- 候补通知送达率
- 补课预约成功率
- 6小时截止执行准确率
- 异步任务执行状态

#### 告警配置
- 通知发送失败告警
- 候补队列满员告警
- 补偿余额异常告警
- 系统性能异常告警

### 运维工具

#### 管理工具
- 候补队列状态查看工具
- 手动通知发送工具
- 补偿余额调整工具
- 数据清理工具

#### 数据分析
- 候补转化率统计
- 补课使用情况分析
- 通知送达效果分析
- 用户行为分析

---

**创建人**: Claude Code Assistant
**创建日期**: 2025-11-08
**版本**: 1.0.0
**状态**: Draft
**文档来源**: specs/003-waitlist-and-makeup/ 目录下的完整规格文档